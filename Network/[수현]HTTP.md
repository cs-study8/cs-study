# HTTP란?

HTTP(HyperText Transfer Protocol)은 웹 상에서 클라이언트와 서버간 데이터를 주고 받기 위한 통신 규약(프로토콜)이다.
통신 규약이란 서버 간 통신을 할 때, 어떠한 형식으로 통신하자고 규정해놓은 "통신 형식" 혹은 "통신 구조"이다. 
예를 들어 두 사람이 서로 대화를 하는데 한 명은 한국어로 한 명은 영어로 말하면 서로 대화를 할 수 없으므로 
서로 이해할 수 있는 공용어를 정해 대화를 해야한다. 마찬가지로 서버 간 통신에서도 서로 이해할 수 있는 공통의 
통신 형식이 필요한데, 이러한 통신 형식을 프로토콜이라고 하고 그 중에서 가장 널리 쓰이는 프로토콜이 HTTP이다.

# HTTP request & response

HTTP는 기본적으로 요청-응답 구조로 되어있다.

![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/ceb70247-8999-4d16-9d6a-968f1925a46e/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210515%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210515T111145Z&X-Amz-Expires=86400&X-Amz-Signature=91c067070b23f45a56ce027beaaa169cdaa136ff24b6f43d80bf07900f4d1521&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

클라이언트는 서버에 HTTP 요청 메시지를 보낸다. HTTP 요청 메시지는 URI와 명령을 포함한다. 서버는 이 요청에 대한 HTTP 응답 메시지를 보낸다.
HTTP 응답 메시지는 상태코드와 메시지 바디를 포함한다.

# Stateful vs Stateless

HTTP는 무상태(Stateless) 프로토콜이다. 상태를 저장하지 않기 때문에(더 정확히는 상태가 없기 때문에) 동일한 클라이언트와 서버가 여러번 통신을 주고받더라도 각각의 통신들은 독립적이며 이전에 처리된 통신에 대해 알지 못한다.
stateful은 그 반대이다. 다음 예시로 stateful과 stateless의 차이를 알 수 있다.

**Stateful**

클라이언트: 노트북 얼마에요?

서버: 100만원 입니다. (노트북 상태 유지)

<br>

클라이언트: 2개 주세요.

서버: 200만원 입니다. 현금과 카드 중 무엇으로 결제하시겠어요? (노트북, 2개 상태 유지)

<br>

클라이언트: 카드로 결제할게요.

서버: 200만원 결제 완료되었습니다. (노트북, 2개, 신용카드 상태 유지)

<br>

**Stateless**

무상태인 경우에는 똑같은 메시지를 다음과 같이 보내야한다. 차이가 나는 부분을 볼드로 강조표시 했다.

<br>

클라이언트: 노트북 얼마에요?

서버: **노트북은** 100만원 입니다.

<br>

클라이언트: **노트북** 2개 구매하겠습니다.

서버: **노트북 2개는** 200만원 입니다. 현금과 카드 중 무엇으로 결제하시겠어요?

<br>

클라이언트: **노트북 2개를 카드**로 결제하겠습니다.

서버: 200만원 결제 완료되었습니다.


## 특징

실제로 우리가 오프라인 매장에서 노트북을 구매할 때 이런 식으로 말을 해야되면 여간 불편한게 아닐 것이다. 
그런데 웹에서는 이런 방식의 통신이 여러 장점을 갖는다.

상태를 유지하는 경우 중간에 서버가 바뀌면 안된다. 서버가 바뀔 때는 상태 정보를 미리 전달해야 한다. 무상태에서는 **중간에
서버가 바뀌어도 된다.** 그래서 무상태에서는 같은 기능을 하는 여러 서버가 있다면 이전에 어떤 서버와 통신했는지 신경쓰지 않고 지금 응답이 가능한 아무 서버에게나 응답을 보낼 수 있다.
이런 방식은 **수평 확장(scale-out)에 유리**하다. 갑자기 요청이 증가해도 서버를 확 늘려서 대응할 수 있다.

하지만 모든 것을 무상태로 처리하는데는 한계가 있다. 대표적인 예로 로그인이 있다. 로그인을 해야만 제공되는 서비스가 있다면, 서버는 클라이언트의 로그인 상태를
저장하고 있어야한다. 그렇지 않으면 클라이언트에서 매 요청마다 로그인 정보를 함께 보내야한다. 따라서 상태를 유지하기 위한 방법으로 쿠키와 세션 등을 이용한다.


# 비연결성(Connectionless)

HTTP는 기본적으로 연결을 유지하지 않는 모델이다. 필요한 요청과 응답이 오고 간 이후에는 바로 연결을 끊어버린다.
우리가 웹사이트를 이용할 때를 생각해보면, 실제로 서버와 클라이언트가 지속적으로 연결을 유지할 필요는 없다(검색을 한번 하고 나면 이후 몇초 간은 검색 버튼을 누르지 않는다).

실제로 수천명이 이용하는 서비스라도 실제 서버에서 동시에 처리하는 요청은 수십개 이하이다.
만약 수천명이 이용하는 웹서버가 요청을 보낸 모든 클라이언트와 지속적으로 연결을 유지한다면 서버 자원이 엄청나게 소모될 것이다.

## 한계와 해결방안

비연결성은 요청과 응답이 있을 때마다 매번 TCP/IP 연결을 새로 맺어야한다는 단점이 있다. 문제는 우리가 웹 브라우저로 사이트를 요청할 때,
HTML 뿐만 아니라 자바스크립트, css, 이미지 등 수 많은 자원이 요청과 응답을 통해 다운로드된다는 점이다. `요청-응답`이 한번 오고갈 때마다 연결을 끊어버리면
추가 자원을 요청해야할 때마다 연결을 다시 수립해야한다.

이 때문에 지금은 HTTP 지속 연결(Persistent Connections)을 통해 문제를 해결하고 있다.

![image](https://user-images.githubusercontent.com/63030569/118361141-f1cea000-b5c4-11eb-8c01-2e79abb415b2.png)
![image](https://user-images.githubusercontent.com/63030569/118361220-538f0a00-b5c5-11eb-8f0f-69e196966dd2.png)
출처: 김영한님 인프런 강의 - [모든 개발자를 위한 HTTP 웹 기본 지식](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard)


# HTTP 메시지

HTTP 메시지에는 HTML 뿐만 아니라 이미지, JSON, 음성, 영상 등 거의 모든 데이터를 담아 보낼 수 있다.

## 구조
기본적으로 다음과 같은 구성요소로 이루어진다. 
* start line
* header
* empty line(CRLF)
* message body

### 요청 메시지
```HTTP
GET /search?q=hello&hl=ko HTTP/1.1
Host: www.google.com

```
post 요청의 경우 메시지 바디가 추가됨

### 응답 메시지 
```HTTP
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8
Content-Length: 3264

<html>
<head>
...
</html>
```



## 메서드

- GET : 리소스 취득
- POST :엔티티 바디 전송
- PUT : 파일 전송
- HEAD : 메시지 헤더 취득
- DELETE : 파일 삭제



## 상태코드

* 2xx : 성공
* 3xx : 리다이렉션 - 클라이언트가 이전 주소(업뎃이 안된)로 데이터를 요청하여 서버에서 새 유알엘로 리다이렉트를 유도
* 4xx : 클라이언트 에러 - 잘못된 요청, 유효하지 않은 자원을 요청했거나 요청이나 권한이 잘못된 경우
* 5xx : 서버 쪽에서 오류가 난 경우






### 참고자료

김영한님 인프런 강의 - [모든 개발자를 위한 HTTP 웹 기본 지식](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard)